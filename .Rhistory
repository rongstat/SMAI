setwd("/Users/rongma/Documents/GitHub/SMAI")
devtools::document()
devtools::document()
devtools::document()
devtools::document()
Crossprod
mat.mult
x <- matrnorm(100, 100)
y <- matrnorm(100, 100)
a <- x
b <- mat.mult(x, y)
b <- Crossprod(x, y)
mat.mult(x, y)
mat.mult(x, y)==Crossprod(x, y)
mat.mult(x, y)==Tcrossprod(x, y)
# split the dataset into a list
data.list <- SplitObject(pbmcsca, split.by = "Method")
# normalize and identify variable features for each dataset independently
data.list <- lapply(X = data.list, FUN = function(x) {
x <- NormalizeData(x)
x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
})
# load dataset
LoadData("pbmcsca")
# split the dataset into a list
data.list <- SplitObject(pbmcsca, split.by = "Method")
# normalize and identify variable features for each dataset independently
data.list <- lapply(X = data.list, FUN = function(x) {
x <- NormalizeData(x)
x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
})
library(Seurat)
library(SeuratData)
library(uwot)
library(ggrepel)
library(ggplot2)
library(cluster)
library(uwot)
library(fossil)
library(batchelor)
library(harmony)
library(rliger)
library(reticulate)
library(SMAI)
install_github("rongstat/SMAI")
library(devtools)
install_github("rongstat/SMAI")
library(SMAI)
align
# load dataset
LoadData("pbmcsca")
# split the dataset into a list
data.list <- SplitObject(pbmcsca, split.by = "Method")
# normalize and identify variable features for each dataset independently
data.list <- lapply(X = data.list, FUN = function(x) {
x <- NormalizeData(x)
x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
})
# select features that are repeatedly variable across datasets for integration
features <- SelectIntegrationFeatures(object.list = data.list)
data.X1 = as.matrix(data.list$`10x Chromium (v2)`@assays$RNA@counts)
ct.X1 = data.list$`10x Chromium (v2)`@meta.data$CellType
data.X2 = as.matrix(data.list$`10x Chromium (v3)`@assays$RNA@counts)
ct.X2 = data.list$`10x Chromium (v3)`@meta.data$CellType
table(ct.X1)
table(ct.X2)
########### feature selection
data.X1 = data.X1[match(features,rownames(data.X1)),]
data.X2 = data.X2[match(features,rownames(data.X2)),]
dim(data.X1)
dim(data.X2)
data.X1 = as.matrix(data.list$`10x Chromium (v2)`@assays$RNA@data)
# split the dataset into a list
data.list <- SplitObject(pbmcsca, split.by = "Method")
# normalize and identify variable features for each dataset independently
data.list <- lapply(X = data.list, FUN = function(x) {
x <- NormalizeData(x)
x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
})
# select features that are repeatedly variable across datasets for integration
features <- SelectIntegrationFeatures(object.list = data.list)
data.X1 = as.matrix(data.list$`10x Chromium (v2)`@assays$RNA@data)
data.X1[1:10,1:10]
data.X2 = as.matrix(data.list$`10x Chromium (v3)`@assays$RNA@counts)
data.X2[1:10,1:10]
data.X2 = as.matrix(data.list$`10x Chromium (v3)`@assays$RNA@data)
data.X2[1:10,1:10]
table(ct.X1)
table(ct.X2)
########### feature selection
data.X1 = data.X1[match(features,rownames(data.X1)),]
data.X2 = data.X2[match(features,rownames(data.X2)),]
dim(data.X1)
dim(data.X2)
out.smai <- align(data.X1, data.X2, t=3, dir.map = "auto",  denoise="scree")
out.smai$p.value
data1=out.smai$data1.integrate
data2=out.smai$data2.integrate
mnn.out = findMutualNN(t(data1),t(data2), k1=15)
prop.align.par = min(c(length(unique(mnn.out$first))/dim(data1)[2],
length(unique(mnn.out$second))/dim(data2)[2]))
prop.align.par
############## SMAI
#identify maximal correspondence subsets
datasets <- list(t(data.X1),t(data.X2))
genes_list <- list((rownames(data.X1)),(rownames(data.X2)))
library(reticulate)
reticulate::use_python("/Users/rongma/opt/miniconda3/envs/scanorama/bin/python")
scanorama <- import('scanorama')
integrated.data <- scanorama$integrate(datasets, genes_list)
corrected.data <- scanorama$correct(datasets, genes_list, return_dense=TRUE)
integrated.corrected.data <- scanorama$correct(datasets, genes_list,
return_dimred=TRUE, return_dense=TRUE)
data1=t(integrated.corrected.data[[2]][[1]])
data2=t(integrated.corrected.data[[2]][[2]])
data1=data1[match(rownames(data.X1.smai),integrated.corrected.data[[3]]),]
data1=t(integrated.corrected.data[[2]][[1]])
data2=t(integrated.corrected.data[[2]][[2]])
data1=data1[match(rownames(data.X1),integrated.corrected.data[[3]]),]
data2=data2[match(rownames(data.X1),integrated.corrected.data[[3]]),]
mnn.out = findMutualNN(t(data1),t(data2), k1=15)
prop.align.par = min(c(length(unique(mnn.out$first))/dim(data1)[2],
length(unique(mnn.out$second))/dim(data2)[2]))
prop.align.par
#start SMAI
set.seed(8)
out.smai <- align(data.X1.smai, data.X2.smai, sel1=unique(mnn.out$first),  sel2=unique(mnn.out$second),
t=3,  dir.map = "auto",  denoise="scree")
out.smai$p.value
#start SMAI
set.seed(8)
out.smai <- align(data.X1, data.X2, sel1=unique(mnn.out$first),  sel2=unique(mnn.out$second),
t=3,  dir.map = "auto",  denoise="scree")
out.smai$p.value
knitr::opts_chunk$set(echo = TRUE)
# split the dataset into a list
data.list <- SplitObject(pbmcsca, split.by = "Method")
# split the dataset into a list
data.list <- SplitObject(pbmcsca, split.by = "Method")
data.X1 = as.matrix(data.list$`10x Chromium (v2)`@assays$RNA@counts)
ct.X1 = data.list$`10x Chromium (v2)`@meta.data$CellType
data.X2 = as.matrix(data.list$`10x Chromium (v3)`@assays$RNA@counts)
ct.X2 = data.list$`10x Chromium (v3)`@meta.data$CellType
dim(data.X1)
dim(data.X2)
table(ct.X1)#cell type attributes in dataset1
table(ct.X2)#cell type attributes in dataset2
all.RNA = cbind(data.X1, data.X2)
all.RNA = cbind(data.X1, data.X2)
meta.data=data.frame(cell_type = factor(c(ct.X1,ct.X2)),
method = factor(c(rep("data1",length(ct.X1)), rep("data2",length(ct.X2)))))
row.names(meta.data)=c(colnames(all.RNA))
row.names(meta.data)=c(colnames(all.RNA))
all.data <- CreateSeuratObject(counts = all.RNA, project = "align", min.cells = 1,
min.features = 1, meta.data = meta.data)
all.data <- SplitObject(all.data, split.by = "method")
all.data <- lapply(X = all.data, FUN = function(x) {
x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
x <- NormalizeData(x)
})
features <- SelectIntegrationFeatures(object.list = all.data)
data.X1.smai = as.matrix(all.data$data1@assays$RNA@data)
data.X2.smai = as.matrix(all.data$data2@assays$RNA@data)
data.X1.smai = data.X1.smai[match(features,rownames(data.X1.smai)),]
data.X2.smai = data.X2.smai[match(features,rownames(data.X2.smai)),]
#Seurat for initial alignment
data.anchors <- FindIntegrationAnchors(object.list = all.data, anchor.features = features)
#Seurat for initial alignment
data.anchors <- FindIntegrationAnchors(object.list = all.data, anchor.features = features)
data.combined <- IntegrateData(anchorset = data.anchors)
dim(data.combined@assays$integrated@data)
#get integrated data
data1=as.matrix(data.combined@assays$integrated@data[,1:length(ct.X1)])
data2=as.matrix(data.combined@assays$integrated@data[,(length(ct.X1)+1):(length(ct.X1)+length(ct.X2))])
#mutual nearest neighbor matching
mnn.out = findMutualNN(t(data1),t(data2), k1=15)
prop.align.par = min(c(length(unique(mnn.out$first))/dim(data1)[2],
length(unique(mnn.out$second))/dim(data2)[2]))
prop.align.par
set.seed(8)
out.smai <- align(data.X1.smai, data.X2.smai, sel1=unique(mnn.out$first),  sel2=unique(mnn.out$second),
t=3, knn=30, r.max=200, dir.map = "auto",  denoise="scree",
prop.align=0.3,  cutoff = 1.001, cutoff.t=1.5)
out.smai$p.value
#UMAP plot
data.int = t(cbind(out.smai$data1.integrate,out.smai$data2.integrate))
#UMAP plot
data.int = t(cbind(out.smai$data1.integrate,out.smai$data2.integrate))
umap.out = umap(data.int, n_neighbors = 50, metric = "cosine", spread = 5)
umap.out = umap(data.int, n_neighbors = 50, metric = "cosine", spread = 5)
meta_data=data.frame(cell_type = factor(c(ct.X1,ct.X2)),
batch = factor(c(rep("X1",length(ct.X1)), rep("X2",length(ct.X2)))))
meta_data=data.frame(cell_type = factor(c(ct.X1,ct.X2)),
batch = factor(c(rep("X1",length(ct.X1)), rep("X2",length(ct.X2)))))
data.plot = data.frame(UMAP1 = c(umap.out[,1]), UMAP2= c(umap.out[,2]),
cell_type = factor(meta_data$cell_type), batch = factor(meta_data$batch))
dim(data.X1)
dim(data.X2)
############## SMAI
#identify maximal correspondence subsets using Scanorama + mutual nearest neighbor matching
datasets <- list(t(data.X1),t(data.X2))
genes_list <- list((rownames(data.X1)),(rownames(data.X2)))
library(reticulate)
reticulate::use_python("/Users/rongma/opt/miniconda3/envs/scanorama/bin/python")
scanorama <- import('scanorama')
integrated.data <- scanorama$integrate(datasets, genes_list)
corrected.data <- scanorama$correct(datasets, genes_list, return_dense=TRUE)
integrated.corrected.data <- scanorama$correct(datasets, genes_list,
return_dimred=TRUE, return_dense=TRUE)
data1=t(integrated.corrected.data[[2]][[1]])
data2=t(integrated.corrected.data[[2]][[2]])
data1=data1[match(rownames(data.X1),integrated.corrected.data[[3]]),]
data2=data2[match(rownames(data.X1),integrated.corrected.data[[3]]),]
#MNN
mnn.out = findMutualNN(t(data1),t(data2), k1=15)
############## SMAI
#identify maximal correspondence subsets using Scanorama + mutual nearest neighbor matching
datasets <- list(t(data.X1),t(data.X2))
genes_list <- list((rownames(data.X1)),(rownames(data.X2)))
library(reticulate)
reticulate::use_python("/Users/rongma/opt/miniconda3/envs/scanorama/bin/python")
scanorama <- import('scanorama')
integrated.data <- scanorama$integrate(datasets, genes_list)
corrected.data <- scanorama$correct(datasets, genes_list, return_dense=TRUE)
integrated.corrected.data <- scanorama$correct(datasets, genes_list,
return_dimred=TRUE, return_dense=TRUE)
data1=t(integrated.corrected.data[[2]][[1]])
data2=t(integrated.corrected.data[[2]][[2]])
data1=data1[match(rownames(data.X1),integrated.corrected.data[[3]]),]
data2=data2[match(rownames(data.X1),integrated.corrected.data[[3]]),]
#MNN
mnn.out = findMutualNN(t(data1),t(data2), k1=15)
dim(data.X1)
dim(data.X2)
# split the dataset into a list
data.list <- SplitObject(pbmcsca, split.by = "Method")
# normalize and identify variable features for each dataset independently
data.list <- lapply(X = data.list, FUN = function(x) {
x <- NormalizeData(x)
x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
})
# select features that are simultaneously variable across datasets for integration
features <- SelectIntegrationFeatures(object.list = data.list)
data.X1 = as.matrix(data.list$`10x Chromium (v2)`@assays$RNA@data)
ct.X1 = data.list$`10x Chromium (v2)`@meta.data$CellType
data.X2 = as.matrix(data.list$`10x Chromium (v3)`@assays$RNA@data)
ct.X2 = data.list$`10x Chromium (v3)`@meta.data$CellType
table(ct.X1)
table(ct.X2)
########### feature selection
data.X1 = data.X1[match(features,rownames(data.X1)),]
data.X2 = data.X2[match(features,rownames(data.X2)),]
dim(data.X1)
dim(data.X2)
############## SMAI
#identify maximal correspondence subsets using Scanorama + mutual nearest neighbor matching
datasets <- list(t(data.X1),t(data.X2))
genes_list <- list((rownames(data.X1)),(rownames(data.X2)))
library(reticulate)
reticulate::use_python("/Users/rongma/opt/miniconda3/envs/scanorama/bin/python")
scanorama <- import('scanorama')
integrated.data <- scanorama$integrate(datasets, genes_list)
corrected.data <- scanorama$correct(datasets, genes_list, return_dense=TRUE)
integrated.corrected.data <- scanorama$correct(datasets, genes_list,
return_dimred=TRUE, return_dense=TRUE)
data1=t(integrated.corrected.data[[2]][[1]])
data2=t(integrated.corrected.data[[2]][[2]])
data1=data1[match(rownames(data.X1),integrated.corrected.data[[3]]),]
data2=data2[match(rownames(data.X1),integrated.corrected.data[[3]]),]
#MNN
mnn.out = findMutualNN(t(data1),t(data2), k1=15)
prop.align.par = min(c(length(unique(mnn.out$first))/dim(data1)[2],
length(unique(mnn.out$second))/dim(data2)[2]))
prop.align.par #[1] 0.4131469 <- something larger than 0.4 recommended.
out.smai <- align(data.X1, data.X2, sel1=unique(mnn.out$first),  sel2=unique(mnn.out$second),
t=3,  dir.map = "auto",  denoise="scree")
out.smai$p.value
meta_data=data.frame(cell_type = factor(c(ct.X1,ct.X2)),
batch = factor(c(rep("X1",length(ct.X1)), rep("X2",length(ct.X2)))))
data.int = t(cbind(out.smai$data1.integrate,out.smai$data2.integrate))
#evaluate structure preservation
faithful(data.int[1:length(ct.X1),], t(data.X1))
faithful(data.int[-c(1:length(ct.X1)),], t(data.X2))
#UMAP plot
data.int = t(cbind(out.smai$data1.integrate,out.smai$data2.integrate))
umap.out = umap(data.int, n_neighbors = 50, metric = "cosine", spread = 5)
meta_data=data.frame(cell_type = factor(c(ct.X1,ct.X2)),
batch = factor(c(rep("X1",length(ct.X1)), rep("X2",length(ct.X2)))))
data.plot = data.frame(UMAP1 = c(umap.out[,1]), UMAP2= c(umap.out[,2]),
cell_type = factor(meta_data$cell_type), batch = factor(meta_data$batch))
p1 <- ggplot(data.plot, aes(x=UMAP1, y=UMAP2, colour = cell_type)) + geom_point(size = 0.7)
p1 <- p1 +  guides(colour = guide_legend(override.aes = list(size=5)))
p1
p1 <- ggplot(data.plot, aes(x=UMAP1, y=UMAP2, colour = batch, alpha=0.5)) + geom_point(size = 0.7)
p1 <- p1 +  guides(colour = guide_legend(override.aes = list(size=5)))
p1
dim(data.X1)
dim(data.X2)
library(batchelor)
setwd("/Users/rongma/Documents/GitHub/SMAI")
devtools::document()
install_github("rongstat/SMAI")
library(SMAI)
library(SMAI)
